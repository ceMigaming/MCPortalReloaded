package com.cemi.portalreloaded.entity;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Random;

import com.cemi.portalreloaded.utility.Path;
import com.cemi.portalreloaded.utility.Path.PathElement;

import net.minecraft.entity.Entity;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.DamageSource;
import net.minecraft.world.World;

public class EntityPathFollowing extends Entity {

	double waitTime = 0.0D;

	double speed = 0.0D;

	boolean shouldFollowPath = false;

	boolean isFollowing = false;

	double xSpeed, ySpeed, zSpeed;
	float pitchRot, yawRot;
	Random r = new Random();

	Path path = new Path();

	PathElement currentElement;

	public EntityPathFollowing(World worldIn) {
		super(worldIn);
		setEntityInvulnerable(true);
	}

	public EntityPathFollowing(World worldIn, double x, double y, double z) {
		super(worldIn);

		setEntityInvulnerable(true);
	}

	@Override
	public boolean isEntityInvulnerable(DamageSource source) {
		return true;
	}

	@Override
	public boolean getIsInvulnerable() {
		return true;
	}

	public void onUpdate() {
		super.onUpdate();
		if (!world.isRemote) {
			if (currentElement != null) {
				if (shouldFollowPath && (Math.abs(this.posX - currentElement.x) > speed
						|| Math.abs(this.posZ - currentElement.z) > speed)) {
					this.motionX = this.xSpeed;
					this.motionY = this.ySpeed;
					this.motionZ = this.zSpeed;
				} else {
					isFollowing = false;
					this.motionX = 0.0D;
					this.motionY = 0.0D;
					this.motionZ = 0.0D;
				}
			} else {
				this.motionX = 0.0D;
				this.motionZ = 0.0D;
			}
			if (waitTime <= 0.0D && !isFollowing) {
				isFollowing = true;
				nextPathElement();
			} else {
				waitTime -= 1.0D / 20.0D;
			}
		}
		setPosition(posX + motionX, posY + motionY, posZ + motionZ);
		setRotation(yawRot, pitchRot);
		// setLocationAndAngles(posX + motionX, posY + motionY, posZ + motionZ, yawRot *
		// (r.nextFloat() * 0.1F - 0.05F),
		// pitchRot * (r.nextFloat() * 0.1F - 0.05F));
	}

	private void nextPathElement() {
		if (path.isFinished())
			return;
		currentElement = path.pop();

		speed = currentElement.speed;

		waitTime = currentElement.waitTime;

		double at2 = Math.atan2(currentElement.z - this.posZ, currentElement.x - this.posX);
		this.xSpeed = Math.cos(at2) * speed;
		this.zSpeed = Math.sin(at2) * speed;

		// this.motionY = 1.0D / 100.0D * Math.sqrt((this.posX - currentElement.x) *
		// (this.posX - currentElement.x)
		// + (this.posZ - currentElement.z) * (this.posZ - currentElement.z));

	}

	public void genDefaultPath() {
		clearPath();
		addPathEntry(5.0D, 10.0D, 5.0D, .25D, 1.0D);
		addPathEntry(-5.0D, 10.0D, 5.0D, .25D, 1.0D);
		addPathEntry(-5.0D, 10.0D, -5.0D, .25D, 1.0D);
		addPathEntry(5.0D, 10.0D, -5.0D, .25D, 1.0D);
		startFollowingPath();
	}

	public void startFollowingPath() {
		path.resetQueue();
		isFollowing = false;
		shouldFollowPath = true;
		String s = path.toString();
		System.out.println(s);
	}

	public void stopFollowingPath() {
		shouldFollowPath = false;
	}

	public void addPathEntry(double x, double y, double z, double speed) {
		path.push(path.new PathElement(x, y, z, speed));
	}

	public void addPathEntry(double x, double y, double z, double speed, double waitTime) {
		path.push(path.new PathElement(x, y, z, speed, waitTime));
	}

	public void addPathEntry(double x, double y, double z, double speed, double waitTime, float pitch, float yaw) {
		path.push(path.new PathElement(x, y, z, speed, waitTime, pitch, yaw));
	}

	public void removeLastPathEntry() {
		path.pop();
	}

	public void removePathEntry(int i) {
		path.removeElementFromPath(i);
	}

	public void skipToPathEntry(int i) {
		path.skipTo(i);
	}

	public void clearPath() {
		path.clear();
	}

	@Override
	protected void entityInit() {
		// TODO Auto-generated method stub

	}

	@Override
	protected void readEntityFromNBT(NBTTagCompound compound) {
		if (compound.hasKey("path")) {
			try {
				path = (Path) convertFromBytes(compound.getByteArray("path"));
			} catch (ClassNotFoundException | IOException e) {
				e.printStackTrace();
			}
		}
	}

	@Override
	protected void writeEntityToNBT(NBTTagCompound compound) {
		try {
			compound.setByteArray("path", convertToBytes(path));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private byte[] convertToBytes(Object object) throws IOException {
		try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
				ObjectOutputStream out = new ObjectOutputStream(bos)) {
			out.writeObject(object);
			return bos.toByteArray();
		}
	}

	private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException {
		try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
				ObjectInputStream in = new ObjectInputStream(bis)) {
			return in.readObject();
		}
	}
}
